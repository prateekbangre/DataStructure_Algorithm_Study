**Keyword to Algorithm**

**"Top k"**
* Heap: K closest points

**"How many ways.."**
* DFS: Decode ways
* DP: Robot paths

**"Substring"**
* Sliding window: Longest substring without repeating characters

**"Palindrome"**
* two pointers: Valid Palindrome

**"Tree"**
* shortest, level-order
* BFS: Binary tree level-order traversal
* else: DFS: Max Depth

**"Parentheses"**
* Stack: Valid Parentheses

**"Subarray"**
* Prefix sum: Subarray sum
* Hashmap: Continuous subarray sum

**"X Sum"**
* Two pointer: Two sum

**"Max/longest sequence"**
* Dynamic programming, DFS: Longest increasing subsequence
* mono deque: Sliding window maximum

**"Minimum/Shortest"**
* Dynammic programming, DFS: Minimal path sum
* BFS: Shortest path

**"Partition/split ... array/string"**
* DFS: Decode ways

**"Subsequence"**
* Dynamic programming, DFS: Longest increasing subsequence
* Sliding window: Longest increasing subsequence

**"Matrix"**
* BFS, DFS: Flood fill, Islands
* Dyanmic programming: Maximal square

**"Jump"**
* Greedy/DP: Jump game

**"Game"**
* Dynamic programming: Divisor game, Stone game

**"Connected component", "Cut/remove" "Regions/groups/connections"**
* Union Find: Number of connected components, Redundant connections

**"Transitive relationship"**

If the items are related to one another and the relationship is transitive, then chances are we can build a graph and use BFS or Union Find.

* string converting to another, BFS: Word Ladder
* string converting to another, BFS, Union Find: Sentence Similarity
* numbers having divisional relationship, BFS, Union Find: Evaluate Division

**"Interval"**
* Greedy: sort by start/end time and then go through sorted intervals Interval Pattern

